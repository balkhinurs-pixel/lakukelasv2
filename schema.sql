-- 1. Enable RLS
alter table public.profiles enable row level security;
alter table public.classes enable row level security;
alter table public.subjects enable row level security;
alter table public.students enable row level security;
alter table public.attendance enable row level security;
alter table public.grades enable row level security;
alter table public.journal_entries enable row level security;
alter table public.agendas enable row level security;
alter table public.schedule enable row level security;
alter table public.settings enable row level security;
alter table public.school_years enable row level security;

-- 2. Create tables
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    full_name text NOT NULL,
    avatar_url text,
    nip text,
    pangkat text,
    jabatan text,
    school_name text,
    school_address text,
    headmaster_name text,
    headmaster_nip text,
    school_logo_url text,
    role text NOT NULL DEFAULT 'teacher'::text,
    active_school_year_id uuid,
    is_homeroom_teacher boolean DEFAULT false,
    email text
);

CREATE TABLE IF NOT EXISTS public.school_years (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL UNIQUE,
    teacher_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.settings (
    id bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    key text NOT NULL UNIQUE,
    value jsonb
);

CREATE TABLE IF NOT EXISTS public.classes (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL,
    teacher_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    school_year_id uuid REFERENCES public.school_years(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS public.subjects (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL,
    kkm integer NOT NULL DEFAULT 75,
    teacher_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.students (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL,
    nis text UNIQUE,
    gender text NOT NULL,
    class_id uuid REFERENCES public.classes(id) ON DELETE SET NULL,
    status text NOT NULL DEFAULT 'active'::text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    avatar_url text
);

CREATE TABLE IF NOT EXISTS public.attendance (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    date date NOT NULL,
    class_id uuid NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
    subject_id uuid NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
    meeting_number integer,
    records jsonb NOT NULL,
    teacher_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    school_year_id uuid REFERENCES public.school_years(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.grades (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    date date NOT NULL,
    class_id uuid NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
    subject_id uuid NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
    assessment_type text NOT NULL,
    records jsonb NOT NULL,
    teacher_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    school_year_id uuid REFERENCES public.school_years(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.journal_entries (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    date timestamp with time zone NOT NULL,
    class_id uuid NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
    subject_id uuid NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
    meeting_number integer,
    learning_objectives text NOT NULL,
    learning_activities text NOT NULL,
    assessment text,
    reflection text,
    teacher_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    school_year_id uuid REFERENCES public.school_years(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS public.agendas (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    date date NOT NULL,
    title text NOT NULL,
    description text,
    tag text,
    color text,
    start_time time without time zone,
    end_time time without time zone,
    teacher_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.schedule (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    day text NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    class_id uuid NOT NULL REFERENCES public.classes(id) ON DELETE CASCADE,
    subject_id uuid NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
    teacher_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.student_notes (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    student_id uuid NOT NULL REFERENCES public.students(id) ON DELETE CASCADE,
    teacher_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    note text NOT NULL,
    type text NOT NULL DEFAULT 'neutral'::text,
    date timestamp with time zone NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.teacher_attendance (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    teacher_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    date date NOT NULL DEFAULT CURRENT_DATE,
    check_in time without time zone,
    check_out time without time zone,
    status text,
    latitude double precision,
    longitude double precision,
    UNIQUE (teacher_id, date)
);


-- 3. Add Foreign Key constraints after tables are created
ALTER TABLE public.profiles
  ADD CONSTRAINT profiles_active_school_year_id_fkey
  FOREIGN KEY (active_school_year_id) REFERENCES public.school_years(id) ON DELETE SET NULL;

-- 4. Create Functions

-- Function to check if a user is an admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  is_admin_role boolean;
BEGIN
  SELECT role = 'admin'
  INTO is_admin_role
  FROM public.profiles
  WHERE id = auth.uid();

  return is_admin_role;
END;
$$;

-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, email, role)
  VALUES (
    new.id,
    COALESCE(new.raw_user_meta_data->>'full_name', SPLIT_PART(new.email, '@', 1)),
    new.email,
    'teacher'
  );
  RETURN new;
END;
$$;


-- 5. Create Policies
-- Profiles
DROP POLICY IF EXISTS "Enable read access for all users" ON public.profiles;
CREATE POLICY "Enable read access for all users" ON public.profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can do anything." ON public.profiles;
CREATE POLICY "Admins can do anything." ON public.profiles FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Classes
DROP POLICY IF EXISTS "Enable read access for all authenticated users" ON public.classes;
CREATE POLICY "Enable read access for all authenticated users" ON public.classes FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admins can manage classes" ON public.classes;
CREATE POLICY "Admins can manage classes" ON public.classes FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Subjects
DROP POLICY IF EXISTS "Enable read access for all authenticated users" ON public.subjects;
CREATE POLICY "Enable read access for all authenticated users" ON public.subjects FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admins can manage subjects" ON public.subjects;
CREATE POLICY "Admins can manage subjects" ON public.subjects FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Students
DROP POLICY IF EXISTS "Enable read access for all authenticated users" ON public.students;
CREATE POLICY "Enable read access for all authenticated users" ON public.students FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admins can manage students" ON public.students;
CREATE POLICY "Admins can manage students" ON public.students FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Attendance
DROP POLICY IF EXISTS "Teachers can manage their own attendance records" ON public.attendance;
CREATE POLICY "Teachers can manage their own attendance records" ON public.attendance FOR ALL USING (auth.uid() = teacher_id) WITH CHECK (auth.uid() = teacher_id);

-- Grades
DROP POLICY IF EXISTS "Teachers can manage their own grade records" ON public.grades;
CREATE POLICY "Teachers can manage their own grade records" ON public.grades FOR ALL USING (auth.uid() = teacher_id) WITH CHECK (auth.uid() = teacher_id);

-- Journal Entries
DROP POLICY IF EXISTS "Teachers can manage their own journal entries" ON public.journal_entries;
CREATE POLICY "Teachers can manage their own journal entries" ON public.journal_entries FOR ALL USING (auth.uid() = teacher_id) WITH CHECK (auth.uid() = teacher_id);

-- Agendas
DROP POLICY IF EXISTS "Teachers can manage their own agendas" ON public.agendas;
CREATE POLICY "Teachers can manage their own agendas" ON public.agendas FOR ALL USING (auth.uid() = teacher_id) WITH CHECK (auth.uid() = teacher_id);

-- Schedule
DROP POLICY IF EXISTS "Admins can manage schedule" ON public.schedule;
CREATE POLICY "Admins can manage schedule" ON public.schedule FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Teachers can view their own schedule" ON public.schedule;
CREATE POLICY "Teachers can view their own schedule" ON public.schedule FOR SELECT USING (auth.uid() = teacher_id);

-- Settings & School Years
DROP POLICY IF EXISTS "Admins can manage settings" ON public.settings;
CREATE POLICY "Admins can manage settings" ON public.settings FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage school years" ON public.school_years;
CREATE POLICY "Admins can manage school years" ON public.school_years FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());


-- 6. Create Triggers
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 7. Create Views (for easier data fetching)

CREATE OR REPLACE VIEW public.attendance_history AS
SELECT
    a.id,
    a.date,
    a.class_id,
    c.name AS class_name,
    a.subject_id,
    s.name AS subject_name,
    a.meeting_number,
    a.records,
    a.teacher_id,
    a.school_year_id,
    EXTRACT(MONTH FROM a.date) as month
FROM
    public.attendance a
JOIN
    public.classes c ON a.class_id = c.id
JOIN
    public.subjects s ON a.subject_id = s.id;

CREATE OR REPLACE VIEW public.grades_history AS
SELECT
    g.id,
    g.date,
    g.class_id,
    c.name AS class_name,
    g.subject_id,
    s.name AS subject_name,
    s.kkm AS subject_kkm,
    g.assessment_type,
    g.records,
    g.teacher_id,
    g.school_year_id,
    EXTRACT(MONTH FROM g.date) as month
FROM
    public.grades g
JOIN
    public.classes c ON g.class_id = c.id
JOIN
    public.subjects s ON g.subject_id = s.id;

CREATE OR REPLACE VIEW public.journal_entries_with_names AS
SELECT
    j.id,
    j.date,
    j.class_id,
    c.name AS class_name,
    j.subject_id,
    s.name AS subject_name,
    j.meeting_number,
    j.learning_objectives,
    j.learning_activities,
    j.assessment,
    j.reflection,
    j.teacher_id,
    j.school_year_id,
    EXTRACT(MONTH FROM j.date) as month
FROM
    public.journal_entries j
JOIN
    public.classes c ON j.class_id = c.id
JOIN
    public.subjects s ON j.subject_id = s.id;

CREATE OR REPLACE VIEW public.student_notes_with_teacher AS
SELECT
    sn.id,
    sn.student_id,
    sn.teacher_id,
    p.full_name as teacher_name,
    sn.note,
    sn.type,
    sn.date
FROM
    public.student_notes sn
JOIN
    public.profiles p ON sn.teacher_id = p.id;

CREATE OR REPLACE VIEW public.teacher_attendance_history AS
SELECT
    ta.id,
    ta.teacher_id,
    p.full_name as teacher_name,
    ta.date,
    ta.check_in,
    ta.check_out,
    ta.status
FROM
    public.teacher_attendance ta
JOIN
    public.profiles p ON ta.teacher_id = p.id;

-- 8. RPC Functions for complex queries

CREATE OR REPLACE FUNCTION public.get_student_grades_ledger(p_student_id uuid)
RETURNS TABLE(id uuid, "subjectName" text, assessment_type text, date date, score numeric, kkm integer)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        g.id,
        s.name as "subjectName",
        g.assessment_type,
        g.date,
        (r->>'score')::numeric as score,
        s.kkm
    FROM
        public.grades g,
        jsonb_to_array(g.records) as arr,
        jsonb_to_string(arr) as r_text,
        jsonb_array_elements(g.records) as r
        JOIN public.subjects s ON g.subject_id = s.id
    WHERE
        (r->>'student_id')::uuid = p_student_id
    ORDER BY g.date DESC;
END;
$$;


CREATE OR REPLACE FUNCTION public.get_student_attendance_ledger(p_student_id uuid)
RETURNS TABLE(id uuid, "subjectName" text, date date, meeting_number int, status text)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        a.id,
        s.name as "subjectName",
        a.date,
        a.meeting_number,
        r->>'status' as status
    FROM
        public.attendance a,
        jsonb_array_elements(a.records) as r
        JOIN public.subjects s ON a.subject_id = s.id
    WHERE
        (r->>'student_id')::uuid = p_student_id
    ORDER BY a.date DESC;
END;
$$;


CREATE OR REPLACE FUNCTION public.get_student_performance_for_class(p_class_id uuid)
RETURNS TABLE(id uuid, name text, nis text, average_grade numeric, attendance_percentage numeric)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH student_grades AS (
        SELECT
            r->>'student_id' as student_id,
            AVG((r->>'score')::numeric) as avg_grade
        FROM
            public.grades g,
            jsonb_array_elements(g.records) as r
        WHERE g.class_id = p_class_id
        GROUP BY 1
    ), student_attendance AS (
        SELECT
            r->>'student_id' as student_id,
            (COUNT(*) FILTER (WHERE r->>'status' = 'Hadir'))::numeric * 100 / COUNT(*)::numeric as att_perc
        FROM
            public.attendance a,
            jsonb_array_elements(a.records) as r
        WHERE a.class_id = p_class_id
        GROUP BY 1
    )
    SELECT
        st.id,
        st.name,
        st.nis,
        COALESCE(ROUND(sg.avg_grade, 1), 0) as average_grade,
        COALESCE(ROUND(sa.att_perc, 1), 0) as attendance_percentage
    FROM
        public.students st
    LEFT JOIN student_grades sg ON st.id = sg.student_id::uuid
    LEFT JOIN student_attendance sa ON st.id = sa.student_id::uuid
    WHERE st.class_id = p_class_id AND st.status = 'active';
END;
$$;
